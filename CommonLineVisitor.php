<?php

require 'vendor/autoload.php';

use PhpParser\Error;
use PhpParser\NodeDumper;
use PhpParser\ParserFactory;
use PhpParser\BuilderFactory;
use PhpParser\Node;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitorAbstract;
use PhpParser\PrettyPrinter;

class CommonLineVisitor extends NodeVisitorAbstract
{

    public string $file_name = '';
    public array $visited_line = array();
    public array $software_line = array();
    private $ignore_line_stack;

    public function __construct($file_name, $visited_line)
    {
        $this->ignore_line_stack = array();
        $this->file_name = $file_name;
        $this->visited_line = $visited_line;
        $this->software_line = array();
    }

    public function enterNode(Node $node)
    {
        if (($node instanceof Node\Stmt\Function_
                || $node instanceof Node\Stmt\ClassMethod
                || $node instanceof Node\Stmt\Class_
                || $node instanceof Node\Stmt\Property
                || $node instanceof Node\Stmt\Namespace_
            ) && !in_array($node->getLine(), $this->software_line)) {
            $this->ignore_line_stack[] = $node->getLine();
            # 扣掉函数体定义，因为XDEBUG动态运行的时候不会访问函数声明语句，类方法定义语句同理
            return null;
        }
        if (!in_array($node->getLine(), $this->software_line))
            $this->software_line[] = $node->getLine();
    }

    public function getCodeCoverage(): array
    {
        $_real_software_line = array_diff($this->software_line, $this->ignore_line_stack); # 扣掉 类声明 函数声明 等 XDEBUG不可能覆盖到的行号，作为全集
        $_real_visited_line = array_intersect($_real_software_line, $this->visited_line); # 取交集，因为XDEBUG会访问一些空RETURN语句
        return array(
            "file_name" => $this->file_name,
            "software_line_cnt" => count($_real_software_line),
            "visited_line_cnt" => count($_real_visited_line),
            "code_coverage" => round(count($_real_visited_line) / count($_real_software_line), 4),
        );
    }

    public function leaveNode(Node $node)
    {
        return parent::leaveNode($node); // TODO: Change the autogenerated stub
    }

    static public function getFunctionSignature($node)
    {
        $params_csv = '';
        for ($i = 0; $i < sizeof($node->params); $i++) {
            $params_csv = $params_csv . $node->params[$i]->var->name . ($i < sizeof($node->params) - 1 ? ',' : '');
        }
        return $node->name . '(' . $params_csv . ')';
    }
}


class FunctionVisitor extends NodeVisitorAbstract
{

    public $file_name = '';
    public $visited_line = array();

    public function __construct($file_name, $visited_line)
    {
        $this->file_name = $file_name;
        $this->visited_line = $visited_line;
    }

    public function enterNode(Node $node)
    {
        if ( # Node is a function and has vars
            ($node instanceof Node\Stmt\Function_ || $node instanceof Node\Stmt\ClassMethod) &&
            sizeof($node->stmts) > 0
        ) {
            /*
             * 第一个IF条件是确保FUNCTION节点
             * 第二个IF条件是确保其有内容，不是抽象方法。
             * 改编自Debloating的用法，但是我们不能够测试函数覆盖率，应该测试code coverage。
             */
            echo "Visit Function " . self::get_function_signature($node);
            $firstStatementLines = range($node->stmts[0]->getStartLine(), $node->getEndLine());
            if (count(array_intersect($firstStatementLines, $this->visited_line)) > 0) {
                # Debloating 工具只检查了交集，是不是大于零，来保证函数是不是被访问。我们可以跟进一步，但是FUNCTION这边可以被保留。
                echo 'Function is covered ' . $this->file_name . ':' . $node->stmts[0]->getStartLine() . ':' . self::get_function_signature($node) . '<br />';
//                $this->software_function_model->add_software_function($this->file_id, $functions_signature, $node->stmts[0]->getStartLine(), 0, -1);
            }
        }
    }

    static public function get_function_signature($node)
    {
        $params_csv = '';
        for ($i = 0; $i < sizeof($node->params); $i++) {
            $params_csv = $params_csv . $node->params[$i]->var->name . ($i < sizeof($node->params) - 1 ? ',' : '');
        }
        return $node->name . '(' . $params_csv . ')';
    }
}